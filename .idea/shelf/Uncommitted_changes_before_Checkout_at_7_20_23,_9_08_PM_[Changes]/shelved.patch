Index: DataProcessor/DataUnpacker.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by Mingcan Li on 11/16/21.\n//\n\n#include \"DataUnpacker.h\"\n\ndouble bytesToDouble(QByteArray data, int start_pos)\n{\n    double number;\n    char* dataPtr = data.data();\n    memcpy(&number, &dataPtr[start_pos], sizeof(double));\n    return number;\n}\n\nfloat bytesToFloat(QByteArray data, int start_pos)\n{\n    float number;\n    char* dataPtr = data.data();\n    memcpy(&number, &dataPtr[start_pos], sizeof(float));\n    return number;\n}\n\ntemplate <typename E>\nE bytesToGeneralData(QByteArray data, int startPos, int endPos, E typeZero)\n{\n    int byteNum=endPos-startPos;\n    auto var = typeZero;\n\n    for(int i = startPos ; i<=endPos ; i++) {\n        var = var + (((uint8_t) data[i]) << (byteNum * 8));\n        byteNum--;\n    }\n\n    return var;\n}\n\n\n\nDataUnpacker::DataUnpacker(QObject *parent) : QObject(parent)\n{\n    FILE* fp = fopen(\"/home/solarcar/firmware/uart-app/sc1-data-format/format.json\", \"r\"); // NOTE: Windows: \"rb\"; non-Windows: \"r\"\n    if(fp == 0) {\n        fp = fopen(\"../uart-app/sc1-data-format/format.json\", \"r\"); // NOTE: Windows: \"rb\"; non-Windows: \"r\"\n        if(fp == 0) {\n            fp = fopen(\"../sc1-driver-io/sc1-data-format/format.json\", \"r\"); // NOTE: Windows: \"rb\"; non-Windows: \"r\"\n        }\n    }\n\n    char readBuffer[65536];\n    FileReadStream is(fp, readBuffer, sizeof(readBuffer));\n\n    Document d;\n    d.ParseStream(is);\n\n    int arrayOffset = 0;\n    backendProcessesOffsets backendOff;\n    int dataCount = 0;\n    cell_group_voltages_begin = -1;\n    cell_group_voltages_end = -1;\n#ifdef FIRMWARE\n    controlsOffsets offsets;\n#endif\n\n    for(Value::ConstMemberIterator itr = d.MemberBegin(); itr != d.MemberEnd(); ++itr) {\n        std::string name = itr->name.GetString();\n        const Value& arr = itr->value.GetArray();\n\n        names.push_back(name);\n        qDebug() << QString::fromStdString(name);\n        byteNums.push_back(arr[0].GetInt());\n        types.push_back(arr[1].GetString());\n\n        if(name == \"tstamp_hr\") {\n            backendOff.tstamp_hr = arrayOffset;\n        } else if(name == \"tstamp_mn\") {\n            backendOff.tstamp_mn = arrayOffset;\n        } else if(name == \"tstamp_sc\") {\n            backendOff.tstamp_sc = arrayOffset;\n        } else if(name == \"tstamp_ms\") {\n            tstampOff.ms = arrayOffset;\n#ifdef FIRMWARE\n        } else if(name == \"horn_status\") {\n            offsets.horn_status = arrayOffset;\n        } else if(name == \"hazards\") {\n            offsets.hazards = arrayOffset;\n        } else if(name == \"headlights\") {\n            offsets.headlights = arrayOffset;\n        } else if(name == \"right_turn\") {\n            offsets.right_turn = arrayOffset;\n        } else if(name == \"left_turn\") {\n            offsets.left_turn = arrayOffset;\n        } else if(name == \"bl_turn_led_en\") {\n            offsets.bl_turn_led_en = arrayOffset;\n        } else if(name == \"br_turn_led_en\") {\n            offsets.br_turn_led_en = arrayOffset;\n        } else if(name == \"bc_brake_led_en\") {\n            offsets.bc_brake_led_en = arrayOffset;\n        } else if(name == \"bc_bps_led_en\") {\n            offsets.bc_bps_led_en = arrayOffset;\n        } else if(name == \"headlights_led_en\") {\n            offsets.headlights_led_en = arrayOffset;\n        } else if(name == \"fr_turn_led_en\") {\n            offsets.fr_turn_led_en = arrayOffset;\n        } else if(name == \"fl_turn_led_en\") {\n            offsets.fl_turn_led_en = arrayOffset;\n        } else if(name == \"driver_power_warning\") {\n            offsets.driver_power_warning = arrayOffset;\n        } else if(name == \"driver_power_critical\") {\n            offsets.driver_power_critical = arrayOffset;\n        } else if(name == \"driver_power_tc\") {\n            offsets.driver_power_tc = arrayOffset;\n        } else if(name == \"driver_power_valid\") {\n            offsets.driver_power_valid = arrayOffset;\n        } else if(name == \"driverIO_temp\") {\n            offsets.driverIO_temp = arrayOffset;\n        } else if(name == \"cabin_temp\") {\n            offsets.cabin_temp = arrayOffset;\n        } else if(name == \"driver_vbus_current\") {\n            offsets.driver_vbus_current = arrayOffset;\n        } else if(name == \"driver_5V_bus\") {\n            offsets.driver_5V_bus = arrayOffset;\n        } else if(name == \"driver_12V_bus\") {\n            offsets.driver_12V_bus = arrayOffset;\n        } else if(name == \"driver_vbus\") {\n            offsets.driver_vbus = arrayOffset;\n        } else if(name == \"mainIO_heartbeat\") {\n            offsets.mainIO_heartbeat = arrayOffset;\n        } else if(name == \"mcu_check\") {\n            offsets.mcu_check = arrayOffset;\n#endif\n        } else if(name.substr(0, 10) == \"cell_group\") {\n            if(cell_group_voltages_begin == -1) {\n                cell_group_voltages_begin = dataCount;\n            } else {\n                cell_group_voltages_end = dataCount;\n            }\n            cell_group_voltages.push_back(0);\n        }\n        qDebug() << cell_group_voltages_begin;\n        arrayOffset += arr[0].GetInt();\n        dataCount++;\n    }\n\n    fclose(fp);\n\n    BackendProcesses* retriever = new BackendProcesses(bytes, names, types, backendOff, mutex);\n\n    retriever->moveToThread(&dataHandlingThread);\n\n    connect(&dataHandlingThread, &QThread::started, retriever, &BackendProcesses::startThread);\n    connect(this, &DataUnpacker::getData, retriever, &BackendProcesses::threadProcedure);\n    connect(retriever, &BackendProcesses::dataReady, this, &DataUnpacker::unpack);\n    connect(retriever, &BackendProcesses::eng_dash_connection, this, &DataUnpacker::eng_dash_connection);\n    connect(this, &DataUnpacker::setMcuHvEn, retriever, &BackendProcesses::setMcuHvEn);\n    connect(&dataHandlingThread, &QThread::finished, retriever, &QObject::deleteLater);\n    connect(&dataHandlingThread, &QThread::finished, &dataHandlingThread, &QThread::deleteLater);\n\n    dataHandlingThread.start();\n\n    //get enviormental variable exported\n#ifdef FIRMWARE\n    QDebug() << \"------ DRIVER-IO FIRMWARE BUILD -------\"\n    controlsWrapper loop = new controlsWrapper(bytes, mutex, restart_enable, offsets);\n    loop->moveToThread(&controlsThread);\n    connect(&controlsThread, &QThread::started, loop, &controlsWrapper::mainProcess);\n    connect(this, &DataUnpacker::goToControlsProcess, loop, &controlsWrapper::mainProcess);\n    connect(loop, &controlsWrapper::endMainProcess, this, &DataUnpacker::controlsWrapperBreak);\n    connect(&controlsThread, &QThread::finished, loop, &QObject::deleteLater);\n    connect(&controlsThread, &QThread::finished, &controlsThread, &QThread::deleteLater);\n    \n    controlsThread.start();\n#endif\n}\n\nDataUnpacker::~DataUnpacker()\n{\n    dataHandlingThread.quit();\n    dataHandlingThread.wait();  //wait until the thread fully stops to avoid error message\n    controlsThread.quit();\n    controlsThread.wait();  //wait until the thread fully stops to avoid error message\n}\n\nvoid DataUnpacker::unpack()\n{\n    int currByte = 0;\n\n    mutex.lock();\n    for(uint i=0; i < names.size(); i++) {\n        if(types[i] == \"float\") {\n            // Make sure the property exists\n            if(this->property(names[i].c_str()).isValid()) {\n                this->setProperty(names[i].c_str(), bytesToFloat(bytes, currByte));\n            } else if((i >= cell_group_voltages_begin) && (i <= cell_group_voltages_end)) {\n                cell_group_voltages[i - cell_group_voltages_begin] = bytesToFloat(bytes, currByte);\n            }\n        } else if(types[i] == \"uint8\") {\n            // Make sure the property exists\n            if(this->property(names[i].c_str()).isValid()) {\n                this->setProperty(names[i].c_str(), bytesToGeneralData(bytes, currByte, currByte + byteNums[i] - 1, (uint8_t)0));\n            }\n        } else if(types[i] == \"uint16\") {\n            // Make sure the property exists\n            if(this->property(names[i].c_str()).isValid()) {\n                this->setProperty(names[i].c_str(), bytesToGeneralData(bytes, currByte, currByte + byteNums[i] - 1, (uint16_t)0));\n            }\n        } else if(types[i] == \"bool\") {\n            // Make sure the property exists\n            if(this->property(names[i].c_str()).isValid()) {\n                this->setProperty(names[i].c_str(), bytesToGeneralData(bytes, currByte, currByte + byteNums[i] - 1, false));\n            }\n        } else if(types[i] == \"char\") {\n            // Make sure the property exists\n            if(this->property(names[i].c_str()).isValid()) {\n                // NOTE: char data is displayed as its ASCII decimal value, not the character, so QString is used instead\n                this->setProperty(names[i].c_str(), QString::fromStdString(std::string(1, bytesToGeneralData(bytes, currByte, currByte + byteNums[i] - 1, (char)0))));\n            }\n        } else if(types[i] == \"double\") {\n            // TODO: No double data yet; Implement when there is double data\n        }\n        currByte += byteNums[i];\n    }\n\n\n    mutex.unlock();\n\n    this->restart_enable = checkRestartEnable();\n\n    // Signal data update for front end\n    emit dataChanged();\n    // Signal to get new data\n    emit getData();\n}\n\nvoid DataUnpacker::eng_dash_connection(bool state) {\n    eng_dash_commfail = !state;\n}\n\nbool DataUnpacker::checkRestartEnable() {\n    return (!restart_enable ? !mcu_hv_en : false) || driver_eStop || external_eStop || imd_status || door || crash || mcu_check || discharge_enable || bps_fault || restart_enable;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DataProcessor/DataUnpacker.cpp b/DataProcessor/DataUnpacker.cpp
--- a/DataProcessor/DataUnpacker.cpp	
+++ b/DataProcessor/DataUnpacker.cpp	
@@ -38,7 +38,7 @@
 
 DataUnpacker::DataUnpacker(QObject *parent) : QObject(parent)
 {
-    FILE* fp = fopen("/home/solarcar/firmware/uart-app/sc1-data-format/format.json", "r"); // NOTE: Windows: "rb"; non-Windows: "r"
+    FILE* fp = fopen("/Users/mcli/Desktop/BadgerLoop/sc1-driver-io/sc1-data-format/format.json", "r"); // NOTE: Windows: "rb"; non-Windows: "r"
     if(fp == 0) {
         fp = fopen("../uart-app/sc1-data-format/format.json", "r"); // NOTE: Windows: "rb"; non-Windows: "r"
         if(fp == 0) {
@@ -77,7 +77,7 @@
         } else if(name == "tstamp_sc") {
             backendOff.tstamp_sc = arrayOffset;
         } else if(name == "tstamp_ms") {
-            tstampOff.ms = arrayOffset;
+            backendOff.tstamp_ms = arrayOffset;
 #ifdef FIRMWARE
         } else if(name == "horn_status") {
             offsets.horn_status = arrayOffset;
